/**
 *  JavaScript wrapper for the GS1 Barcode Syntax Engine compiled as a WASM by
 *  Emscripten.
 *
 *  Copyright (c) 2022-2026 GS1 AISBL.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

'use strict';


/*
 *  Note: gs1encoder-wasm.js and gs1encoder-wasm.wasm can be generated by
 *  running "make wasm" in the src/c-lib directory, provided that the EMSDK is
 *  installed and activated.
 *
 *  Most browsers require that the .wasm is served with the MIME type set as
 *  "application/wasm".
 *
 */
import createGS1encoderModule from './gs1encoder-wasm.mjs';


/**
 * Main class for processing GS1 barcode data, including validation, format conversion, and generation of outputs such as GS1 Digital Link URIs and Human-Readable Interpretation text.
 */
export class GS1encoder {

    /**
     * Creates a new GS1Encoder instance. Call {@link GS1encoder#init} to initialise it before use.
     */
    constructor() {
        /**
         * @private
         */
        this.ctx = null;
    }

    /**
     * Initialises a new instance of the GS1Encoder.
     *
     * @returns {Promise<void>}
     * @throws {GS1encoderGeneralException} if the library fails to initialise
     * @async
     */
    async init() {

        /**
         *  Load the WASM
         *  @private
         */
        this.module = await createGS1encoderModule();

        /**
         *  Public API functions implemented by the WASM build of the GS1
         *  Syntax Engine library
         *  @private
         */
        this.api = {
            gs1_encoder_getVersion:
                this.module.cwrap('gs1_encoder_getVersion', 'string', []),
            gs1_encoder_init:
                this.module.cwrap('gs1_encoder_init', 'number', []),
            gs1_encoder_free:
                this.module.cwrap('gs1_encoder_free', '', ['number']),
            gs1_encoder_getErrMsg:
                this.module.cwrap('gs1_encoder_getErrMsg', 'string', ['number']),
            gs1_encoder_getErrMarkup:
                this.module.cwrap('gs1_encoder_getErrMarkup', 'string', ['number']),
            gs1_encoder_getSym:
                this.module.cwrap('gs1_encoder_getSym', 'number', ['number']),
            gs1_encoder_setSym:
                this.module.cwrap('gs1_encoder_setSym', 'number', ['number', 'number']),
            gs1_encoder_getAddCheckDigit:
                this.module.cwrap('gs1_encoder_getAddCheckDigit', 'number', ['number']),
            gs1_encoder_setAddCheckDigit:
                this.module.cwrap('gs1_encoder_setAddCheckDigit', 'number', ['number', 'number']),
            gs1_encoder_getPermitUnknownAIs:
                this.module.cwrap('gs1_encoder_getPermitUnknownAIs', 'number', ['number']),
            gs1_encoder_setPermitUnknownAIs:
                this.module.cwrap('gs1_encoder_setPermitUnknownAIs', 'number', ['number', 'number']),
            gs1_encoder_getPermitZeroSuppressedGTINinDLuris:
                this.module.cwrap('gs1_encoder_getPermitZeroSuppressedGTINinDLuris', 'number', ['number']),
            gs1_encoder_setPermitZeroSuppressedGTINinDLuris:
                this.module.cwrap('gs1_encoder_setPermitZeroSuppressedGTINinDLuris', 'number', ['number', 'number']),
            gs1_encoder_getIncludeDataTitlesInHRI:
                this.module.cwrap('gs1_encoder_getIncludeDataTitlesInHRI', 'number', ['number']),
            gs1_encoder_setIncludeDataTitlesInHRI:
                this.module.cwrap('gs1_encoder_setIncludeDataTitlesInHRI', 'number', ['number', 'number']),
            gs1_encoder_getValidationEnabled:
                this.module.cwrap('gs1_encoder_getValidationEnabled', 'number', ['number', 'number']),
            gs1_encoder_setValidationEnabled:
                this.module.cwrap('gs1_encoder_setValidationEnabled', 'number', ['number', 'number', 'number']),
            gs1_encoder_getValidateAIassociations:
                this.module.cwrap('gs1_encoder_getValidateAIassociations', 'number', ['number']),
            gs1_encoder_setValidateAIassociations:
                this.module.cwrap('gs1_encoder_setValidateAIassociations', 'number', ['number', 'number']),
            gs1_encoder_setAIdataStr:
                this.module.cwrap('gs1_encoder_setAIdataStr', 'number', ['number', 'string']),
            gs1_encoder_getAIdataStr:
                this.module.cwrap('gs1_encoder_getAIdataStr', 'number', ['number']),
            gs1_encoder_setDataStr:
                this.module.cwrap('gs1_encoder_setDataStr', 'number', ['number', 'string']),
            gs1_encoder_getDataStr:
                this.module.cwrap('gs1_encoder_getDataStr', 'string', ['number']),
            gs1_encoder_getDLuri:
                this.module.cwrap('gs1_encoder_getDLuri', 'string', ['number', 'string']),
            gs1_encoder_setScanData:
                this.module.cwrap('gs1_encoder_setScanData', 'number', ['number', 'string']),
            gs1_encoder_getScanData:
                this.module.cwrap('gs1_encoder_getScanData', 'string', ['number']),
            gs1_encoder_getHRI:
                this.module.cwrap('gs1_encoder_getHRI', 'number', ['number', 'number']),
            gs1_encoder_getDLignoredQueryParams:
                this.module.cwrap('gs1_encoder_getDLignoredQueryParams', null, ['number', 'number']),
        };

        this.ctx = this.api.gs1_encoder_init(null);
        if (this.ctx === null)
            throw new GS1encoderGeneralException("Failed to initialise GS1 Barcode Syntax Engine");

    }


    /**
     * Frees the resources associated with this encoder instance.
     * @returns {void}
     */
    free() {
        if (this.ctx !== null) {
            this.api.gs1_encoder_free(this.ctx);
            this.ctx = null;
        }
    }


    /**
     * Get the version string of the library.
     * <p>
     * Returns a string containing the version of the library, typically the build date.
     *
     * @type {string}
     * @returns {string}
     */
    get version() {
        return this.api.gs1_encoder_getVersion();
    }


    /**
     * Get the error markup generated when parsing AI data fails due to a linting failure.
     * <p>
     * When a setter function returns <code>false</code> (indicating an error), if that failure is due to
     * AI-based data being invalid, a marked up instance of the AI that failed will be generated.
     * <p>
     * Where it is meaningful to identify offending characters in the input data, these characters
     * will be surrounded by <code>"|"</code> characters. Otherwise the entire AI value will be surrounded by
     * <code>"|"</code> characters.
     *
     * @type {string}
     * @returns {string}
     */
    get errMarkup() {
        return this.api.gs1_encoder_getErrMarkup(this.ctx);
    }


    /**
     * Get/set the symbology type.
     * <p>
     * This might be set manually or automatically when processing scan data with {@link GS1encoder#scanData}.
     *
     * @type {Symbology}
     * @returns {Symbology}
     * @throws {GS1encoderParameterException} if the setter is provided with an invalid symbology type
     * @see {@link GS1encoder#scanData}
     * @see GS1encoder.symbology
     */
    get sym() {
        return this.api.gs1_encoder_getSym(this.ctx);
    }
    /**
     * @param {Symbology} value
     */
    set sym(value) {
        if (!this.api.gs1_encoder_setSym(this.ctx, value))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get/set the "add check digit" mode for EAN/UPC and GS1 DataBar symbols.
     * <p>
     * If <code>false</code> (default), then the data string must contain a valid check digit.
     * If <code>true</code>, then the data string must not contain a check digit as one will
     * be generated automatically.
     * <p>
     * This option is only valid for symbologies that accept fixed-length data,
     * specifically EAN/UPC and GS1 DataBar except Expanded (Stacked).
     *
     * @type {boolean}
     * @returns {boolean}
     * @throws {GS1encoderParameterException} if the value is invalid
     */
    get addCheckDigit() {
        return this.api.gs1_encoder_getAddCheckDigit(this.ctx) != 0;
    }
    /**
     * @param {boolean} value
     */
    set addCheckDigit(value) {
        if (!this.api.gs1_encoder_setAddCheckDigit(this.ctx, value ? 1 : 0))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get/set the "permit unknown AIs" mode.
     * <p>
     * If <code>false</code> (default), then all AIs represented by the input data must be
     * known.
     * <p>
     * If <code>true</code>, then unknown AIs (those not in this library's static AI table)
     * will be accepted.
     * <p>
     * <strong>Note:</strong> The option only applies to parsed input data, specifically bracketed AI data
     * supplied with {@link GS1encoder#aiDataStr} and GS1 Digital Link URIs supplied
     * with {@link GS1encoder#dataStr}. Unbracketed AI element strings containing
     * unknown AIs cannot be parsed because it is not possible to differentiate the
     * AI from its data value when the length of the AI is uncertain.
     * <p>
     * Default: <code>false</code>
     *
     * @type {boolean}
     * @throws {@link GS1encoderParameterException}
     */
    get permitUnknownAIs() {
        return this.api.gs1_encoder_getPermitUnknownAIs(this.ctx) != 0;
    }
    set permitUnknownAIs(value) {
        if (!this.api.gs1_encoder_setPermitUnknownAIs(this.ctx, value ? 1 : 0))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get/set the "permit zero-suppressed GTIN in GS1 DL URIs" mode.
     * <p>
     * If false (default), then the value of a path component for AI (01) must
     * be provided as a full GTIN-14.
     * <p>
     * If true, then the value of a path component for AI (01) may contain the
     * GTIN-14 with zeros suppressed, in the format of a GTIN-13, GTIN-12 or GTIN-8.
     * <p>
     * This option only applies to parsed input data, specifically GS1 Digital Link
     * URIs. Since zero-suppressed GTINs are deprecated, this option should only be
     * enabled when it is necessary to accept legacy GS1 Digital Link URIs having
     * zero-suppressed GTIN-14.
     * <p>
     * Default: false
     *
     * @type {boolean}
     * @throws {@link GS1encoderParameterException}
     */
    get permitZeroSuppressedGTINinDLuris() {
        return this.api.gs1_encoder_getPermitZeroSuppressedGTINinDLuris(this.ctx) != 0;
    }
    set permitZeroSuppressedGTINinDLuris(value) {
        if (!this.api.gs1_encoder_setPermitZeroSuppressedGTINinDLuris(this.ctx, value ? 1 : 0))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get/set the "include data titles in HRI" flag.
     * <p>
     * When set to <code>true</code>, data titles from the GS1 General Specification will be
     * included in the HRI text.
     * <p>
     * Default: <code>false</code>
     *
     * @type {boolean}
     * @throws {@link GS1encoderParameterException}
     */
    get includeDataTitlesInHRI() {
        return this.api.gs1_encoder_getIncludeDataTitlesInHRI(this.ctx) != 0;
    }
    set includeDataTitlesInHRI(value) {
        if (!this.api.gs1_encoder_setIncludeDataTitlesInHRI(this.ctx, value ? 1 : 0))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get the current enabled status of the provided AI validation procedure.
     *
     * @param {Validation} validation - A validation procedure to check the status of
     * @returns {boolean} <code>true</code> if the AI validation procedure is currently enabled; <code>false</code> otherwise
     */
    getValidationEnabled(validation) {
        return this.api.gs1_encoder_getValidationEnabled(this.ctx, validation) != 0;
    }


    /**
     * Enable or disable the given AI validation procedure.
     * <p>
     * This determines whether certain checks are enforced when data is provided using
     * {@link GS1encoder#aiDataStr}, {@link GS1encoder#dataStr} or {@link GS1encoder#scanData}.
     * <p>
     * If enabled is <code>true</code> (default), then the corresponding validation will be enforced.
     * If enabled is <code>false</code>, then the corresponding validation will not be enforced.
     * <p>
     * <strong>Note:</strong> The option only applies to AI input data.
     *
     * @param {Validation} validation - A validation procedure to set the enabled status of
     * @param {boolean} value - <code>true</code> to enable the validation; <code>false</code> to disable
     * @returns {void}
     * @throws {GS1encoderParameterException}
     */
    setValidationEnabled(validation, value) {
        if (!this.api.gs1_encoder_setValidationEnabled(this.ctx, validation, value ? 1 : 0))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get/set the "validate AI associations" flag.
     * <p>
     * <strong>Deprecated:</strong> Use {@link GS1encoder#getValidationEnabled} and
     * {@link GS1encoder#setValidationEnabled} instead.
     * <p>
     * This property is equivalent to using the {@link GS1encoder#getValidationEnabled} and
     * {@link GS1encoder#setValidationEnabled} methods with the
     * {@link GS1encoder.validation RequisiteAIs} validation procedure.
     *
     * @type {boolean}
     * @deprecated Use {@link GS1encoder#getValidationEnabled} and {@link GS1encoder#setValidationEnabled} instead
     * @throws {@link GS1encoderParameterException}
     */
    get validateAIassociations() {
        return this.getValidationEnabled(GS1encoder.validation.RequisiteAIs);
    }
    set validateAIassociations(value) {
        this.setValidationEnabled(GS1encoder.validation.RequisiteAIs, value);
    }


    /**
     * Get/set the barcode data input buffer using GS1 Application Identifier syntax.
     * <p>
     * The input is provided in human-friendly format <strong>without</strong> FNC1 characters
     * which are inserted automatically, for example:
     * <p>
     * <pre>(01)12345678901231(10)ABC123(11)210630</pre>
     * <p>
     * This syntax harmonises the format for the input accepted by all symbologies.
     * For example, the following input is acceptable for EAN-13, UPC-A, UPC-E, any
     * variant of the GS1 DataBar family, GS1 QR Code and GS1 DataMatrix:
     * <p>
     * <pre>(01)00031234000054</pre>
     * <p>
     * The input is immediately parsed and validated against certain rules for GS1 AIs, after
     * which the resulting encoding for valid inputs is available via {@link GS1encoder#dataStr}.
     * If the input is invalid then an exception will be thrown.
     * <p>
     * Any <code>"("</code> characters in AI element values must be escaped as <code>"\\("</code> to avoid
     * conflating them with the start of the next AI.
     * <p>
     * For symbologies that support a composite component (all except Data Matrix, QR Code,
     * and DotCode), the data for the linear and 2D components can be separated by a
     * <code>"|"</code> character, for example:
     * <p>
     * <pre>(01)12345678901231|(10)ABC123(11)210630</pre>
     *
     * @type {string}
     * @throws {@link GS1encoderParameterException}
     */
    get aiDataStr() {
        var c_str = this.api.gs1_encoder_getAIdataStr(this.ctx);
        if (!c_str)
            return null;
        return this.module.UTF8ToString(c_str);
    }
    set aiDataStr(value) {
        if (!this.api.gs1_encoder_setAIdataStr(this.ctx, value))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }

    /**
     * Get/set the raw data that would be directly encoded within a GS1 barcode message.
     * <p>
     * A <code>"^"</code> character at the start of the input indicates that the data is in GS1
     * Application Identifier syntax. In this case, all subsequent instances of the
     * <code>"^"</code> character represent the FNC1 non-data characters that are used to
     * separate fields that are not specified as being pre-defined length from
     * subsequent fields.
     * <p>
     * Inputs beginning with <code>"^"</code> will be validated against certain data syntax
     * rules for GS1 AIs. If the input is invalid then the setter will throw
     * a {@link GS1encoderParameterException}. In the case that the data is
     * unacceptable due to invalid AI content then a marked up version of the
     * offending AI can be retrieved using {@link GS1encoder#errMarkup}.
     * <p>
     * <strong>Note:</strong> It is strongly advised that GS1 data input is instead specified using
     * {@link GS1encoder#aiDataStr} which takes care of the AI encoding rules
     * automatically, including insertion of FNC1 characters where required. This
     * can be used for all symbologies that accept GS1 AI syntax data.
     * <p>
     * Inputs beginning with <code>"http://"</code> or <code>"https://"</code> will be parsed as a GS1
     * Digital Link URI during which the corresponding AI element string is
     * extracted and validated.
     * <p>
     * EAN/UPC, GS1 DataBar and GS1-128 support a Composite Component. The
     * Composite Component must be specified in AI syntax. It must be separated
     * from the primary linear components with a <code>"|"</code> character and begin with an
     * FNC1 in first position, for example:
     * <pre>
     * encoder.dataStr = "^0112345678901231|^10ABC123^11210630";
     * </pre>
     * <p>
     * The above specifies a linear component representing "(01)12345678901231"
     * together with a composite component representing "(10)ABC123(11)210630".
     * <p>
     * <strong>Note:</strong> For GS1 data it is simpler and less error prone to specify the input
     * in human-friendly GS1 AI syntax using {@link GS1encoder#aiDataStr}.
     *
     * @type {string}
     * @throws {@link GS1encoderParameterException} if the setter is provided with invalid data
     * @see {@link GS1encoder#aiDataStr}
     * @see {@link GS1encoder#errMarkup}
     */
    get dataStr() {
        return this.api.gs1_encoder_getDataStr(this.ctx);
    }
    set dataStr(value) {
        if (!this.api.gs1_encoder_setDataStr(this.ctx, value))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get a GS1 Digital Link URI that represents the AI-based input data.
     * <p>
     * This method converts AI-based input data into a GS1 Digital Link URI format.
     * <p>
     * Example: <pre>(01)12345678901231(10)ABC123(11)210630</pre> with stem
     * <code>https://id.example.com/stem</code> might produce:
     * <pre>https://id.example.com/stem/01/12345678901231?10=ABC123&11=210630</pre>
     *
     * @param {string|null} stem - A URI "stem" used as a prefix for the URI. If <code>null</code>, the GS1 canonical stem (https://id.gs1.org/) will be used
     * @returns {string} a string representing the GS1 Digital Link URI for the input data
     * @throws {GS1encoderDigitalLinkException}
     */
    getDLuri(stem) {
        var uri = this.api.gs1_encoder_getDLuri(this.ctx, stem);
        if (!uri)
            throw new GS1encoderDigitalLinkException(this.api.gs1_encoder_getErrMsg(this.ctx));
        return uri;
    }


    /**
     * Process scan data received from a barcode reader or return the expected scan data string.
     * <p>
     * <strong>Setting:</strong> Process normalised scan data received from a barcode reader with
     * reporting of AIM symbology identifiers enabled to extract the message data and perform
     * syntax checks in the case of GS1 Digital Link and AI data input.
     * <p>
     * This function will process scan data (such as the output of a barcode reader) and process
     * the received data, setting the data input buffer to the message received and setting the
     * selected symbology to something that is able to carry the received data.
     * <p>
     * <strong>Note:</strong> In some instances the symbology determined by this library will not match
     * that of the image that was scanned. The AIM symbology identifier prefix of the
     * scan data does not always uniquely identify the symbology that was scanned.
     * For example GS1-128 Composite symbols share the same symbology identifier as
     * the GS1 DataBar family, and will therefore be detected as such.
     * <p>
     * A literal <code>"|"</code> character may be included in the scan data to indicate the
     * separation between the first and second messages that would be transmitted
     * by a reader that is configured to return the composite component when
     * reading EAN/UPC symbols.
     * <p>
     * Example scan data input: <pre>]C1011231231231233310ABC123{GS}99TESTING</pre>
     * where {GS} represents ASCII character 29.
     * <p>
     * <strong>Getting:</strong> Returns the string that should be returned by scanners when reading a
     * symbol that is an instance of the selected symbology and contains the same input data.
     * <p>
     * The output will be prefixed with the appropriate AIM symbology identifier.
     *
     * @type {string}
     * @throws {@link GS1encoderParameterException}
     */
    get scanData() {
        return this.api.gs1_encoder_getScanData(this.ctx);
    }
    set scanData(value) {
        if (!this.api.gs1_encoder_setScanData(this.ctx, value))
            throw new GS1encoderParameterException(this.api.gs1_encoder_getErrMsg(this.ctx));
    }


    /**
     * Get the Human-Readable Interpretation ("HRI") text for the current data input buffer.
     * <p>
     * For composite symbols, a separator "--" will be included in the array to distinguish
     * between the linear and 2D components.
     * <p>
     * Example output for <code>^011231231231233310ABC123|^99XYZ(TM) CORP</code>:
     * <pre>
     * (01) 12312312312333
     * (10) ABC123
     * --
     * (99) XYZ(TM) CORP
     * </pre>
     *
     * @type {string[]}
     * @returns {string[]}
     */
    get hri() {
        var ptr = this.module._malloc(Uint32Array.BYTES_PER_ELEMENT);
        var size = this.api.gs1_encoder_getHRI(this.ctx, ptr);
        var hri = Array(size);
        for (var i = 0, p = this.module.getValue(ptr, 'i32');
             i < size;
             i++, p += Uint32Array.BYTES_PER_ELEMENT) {
            hri[i] = this.module.UTF8ToString(this.module.getValue(p, 'i32'));
        }
        return hri;
    }


    /**
     * Get the non-numeric (ignored) query parameters from a GS1 Digital Link URI.
     * <p>
     * For example, if the input data buffer contains:
     * <pre>https://a/01/12312312312333/22/ABC?name=Donald%2dDuck&amp;99=ABC&amp;testing&amp;type=cartoon</pre>
     * <p>
     * Then this property returns: <code>name=Donald%2dDuck</code>, <code>testing</code>, <code>type=cartoon</code>
     * <p>
     * The returned strings are not URI decoded. The expected use for this property is to
     * present which sections of a given GS1 Digital Link URI have been ignored.
     *
     * @type {string[]}
     * @returns {string[]}
     */
    get dlIgnoredQueryParams() {
        var ptr = this.module._malloc(Uint32Array.BYTES_PER_ELEMENT);
        var size = this.api.gs1_encoder_getDLignoredQueryParams(this.ctx, ptr);
        var qp = Array(size);
        for (var i = 0, p = this.module.getValue(ptr, 'i32');
             i < size;
             i++, p += Uint32Array.BYTES_PER_ELEMENT) {
            qp[i] = this.module.UTF8ToString(this.module.getValue(p, 'i32'));
        }
        return qp;
    }

}


/**
 * Recognised GS1 barcode formats ("symbologies") for processing scan data.
 * <p>
 * This object defines all supported GS1 barcode symbology types that can be used
 * with the encoder. Each symbology has specific characteristics and use cases.
 *
 * @typedef {number} Symbology - Numeric symbology identifier
 */

/**
 * @typedef {object} SymbologyEnum
 * @property {Symbology} NONE None defined
 * @property {Symbology} DataBarOmni GS1 DataBar Omnidirectional
 * @property {Symbology} DataBarTruncated GS1 DataBar Truncated
 * @property {Symbology} DataBarStacked GS1 DataBar Stacked
 * @property {Symbology} DataBarStackedOmni GS1 DataBar Stacked Omnidirectional
 * @property {Symbology} DataBarLimited GS1 DataBar Limited
 * @property {Symbology} DataBarExpanded GS1 DataBar Expanded (Stacked)
 * @property {Symbology} UPCA UPC-A
 * @property {Symbology} UPCE UPC-E
 * @property {Symbology} EAN13 EAN-13
 * @property {Symbology} EAN8 EAN-8
 * @property {Symbology} GS1_128_CCA GS1-128 with CC-A or CC-B
 * @property {Symbology} GS1_128_CCC GS1-128 with CC-C
 * @property {Symbology} QR (GS1) QR Code
 * @property {Symbology} DM (GS1) Data Matrix
 * @property {Symbology} DotCode (GS1) DotCode
 * @property {Symbology} NUMSYMS Value is the number of symbologies
 * @readonly
 */

/** @type {SymbologyEnum} */
const symbology = {
    NONE: -1,
    DataBarOmni: 0,
    DataBarTruncated: 1,
    DataBarStacked: 2,
    DataBarStackedOmni: 3,
    DataBarLimited: 4,
    DataBarExpanded: 5,
    UPCA: 6,
    UPCE: 7,
    EAN13: 8,
    EAN8: 9,
    GS1_128_CCA: 10,
    GS1_128_CCC: 11,
    QR: 12,
    DM: 13,
    DotCode: 14,
    NUMSYMS: 15,
};

GS1encoder.symbology = symbology;


/**
 * Optional AI validation procedures that may be applied to detect invalid inputs.
 * <p>
 * These validation procedures are applied when AI data is provided using
 * {@link GS1encoder#aiDataStr}, {@link GS1encoder#dataStr} or {@link GS1encoder#scanData}.
 * <p>
 * Only AI validation procedures whose "enabled" status can be updated (i.e. not "locked") are described.
 *
 * @typedef {number} Validation - Numeric validation identifier
 */

/**
 * @typedef {object} ValidationEnum
 * @property {Validation} MutexAIs Mutually exclusive AIs (locked: always enabled)
 * @property {Validation} RequisiteAIs Mandatory associations between AIs
 * @property {Validation} RepeatedAIs Repeated AIs having same value (locked: always enabled)
 * @property {Validation} DigSigSerialKey Serialisation qualifier AIs must be present with Digital Signature (locked: always enabled)
 * @property {Validation} UnknownAInotDLattr Unknown AIs not permitted as GS1 DL URI data attributes
 * @property {Validation} NUMVALIDATIONS Value is the number of validations
 * @readonly
 */

/** @type {ValidationEnum} */
const validation = {
    MutexAIs: 0,
    RequisiteAIs: 1,
    RepeatedAIs: 2,
    DigSigSerialKey: 3,
    UnknownAInotDLattr: 4,
    NUMVALIDATIONS: 5,
};

GS1encoder.validation = validation;


/**
 * Exception thrown when a general library error occurs, such as initialisation failure.
 * @class
 * @extends Error
 * @param {string} message - The error message
 */
function GS1encoderGeneralException(message) {
    const error = new Error(message);
    error.name = 'GS1encoderGeneralException';
    return error;
}
GS1encoderGeneralException.prototype = Object.create(Error.prototype);
GS1encoderGeneralException.prototype.name = 'GS1encoderGeneralException';


/**
 * Exception thrown when an invalid parameter is provided to a method or property setter.
 * @class
 * @extends Error
 * @param {string} message - The error message
 */
function GS1encoderParameterException(message) {
    const error = new Error(message);
    error.name = 'GS1encoderParameterException';
    return error;
}
GS1encoderParameterException.prototype = Object.create(Error.prototype);
GS1encoderParameterException.prototype.name = 'GS1encoderParameterException';


/**
 * Exception thrown when an error occurs during GS1 Digital Link URI processing.
 * @class
 * @extends Error
 * @param {string} message - The error message
 */
function GS1encoderDigitalLinkException(message) {
    const error = new Error(message);
    error.name = 'GS1encoderDigitalLinkException';
    return error;
}
GS1encoderDigitalLinkException.prototype = Object.create(Error.prototype);
GS1encoderDigitalLinkException.prototype.name = 'GS1encoderDigitalLinkException';


/**
 * Exception thrown when an error occurs during scan data processing.
 * @class
 * @extends Error
 * @param {string} message - The error message
 */
function GS1encoderScanDataException(message) {
    const error = new Error(message);
    error.name = 'GS1encoderScanDataException';
    return error;
}
GS1encoderScanDataException.prototype = Object.create(Error.prototype);
GS1encoderScanDataException.prototype.name = 'GS1encoderScanDataException';

export { GS1encoderGeneralException, GS1encoderParameterException, GS1encoderDigitalLinkException, GS1encoderScanDataException, symbology as Symbology, validation as Validation };
