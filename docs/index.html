<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GS1 Barcode Syntax Engine: GS1 Barcode Syntax Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GS1 Barcode Syntax Engine
   </div>
   <div id="projectbrief">Library for processing GS1 Application Identifier syntax</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">GS1 Barcode Syntax Engine </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a> </p>
<h2><a class="anchor" id="autotoc_md0"></a>
Overview</h2>
<p>The GS1 Barcode Syntax Engine provides routines that support the processing of GS1 syntax data, including Application Identifier element strings and GS1 Digital Link URIs, whether these are provided in raw or human-friendly format or as normalised scan data received from barcode readers.</p>
<p>The implementations are intended for use with GS1 standards and applications and do not contain additional features that might be required for more general use.</p>
<p>Within the GS1 Application Identifier system, structured data is represented in different formats depending upon the context.</p>
<p>The data formats supported by this library are:</p>
<ul>
<li><b>Bracketed AI element strings</b>: Human-friendly rendition of AI data as a single string using numerical AIs.</li>
<li><b>Unbracketed AI element strings</b>: Rendition of AI data that corresponds most directly to encoded barcode data.</li>
<li><b>GS1 Digital Link URIs</b></li>
<li><b>Scan data</b>: The expected result of scanning a symbol with a barcode reader that has AIM symbologies identifiers enabled.</li>
<li><b>Human Readable Interpretation (HRI)</b>: Human-friendly redition of the AI data contained within a symbol. This may also include Data Titles to present the AI data in the form of "mixed HRI/non-HRI text". (Output only.)</li>
</ul>
<p>This following diagram shows how the library can be used for processing and transformation of GS1 data, indicating which formats are accepted as input, how barcode message data is generated and AI data extracted from the provided input data, and how the given data can be output in various formats.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Data transformation: Inputs, outputs and buffers    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><div class="image">
<object type="image/svg+xml" data="input_output_buffers.svg" style="pointer-events: none;"></object>
</div>
  </td></tr>
</table>
<p>The above diagram highlights that conceptually the library contains two internal "data buffers":</p>
<ul>
<li><b>Barcode message buffer:</b> This is populated with the raw message that would be borne by a GS1 barcode symbol that represents the input data, e.g. unbracketed AI syntax with FNC1 in first for regular AI element strings; plain string for a plain data or a GS1 Digital Link URI.</li>
<li><b>Extracted AI buffer:</b> This contains the in-order AI data that was extracted from the input data.</li>
</ul>
<p>The main operations of the library involve reading and updating the state of these buffers.</p>
<h2><a class="anchor" id="quick-start"></a>
Quick Start</h2>
<h3><a class="anchor" id="autotoc_md1"></a>
Building the C library</h3>
<p><b>On Unix/macOS:</b></p>
<p>Build as a shared library: </p><pre class="fragment">make -C src/c-lib -j `nproc` libshared
</pre><p> Or build as a static library: </p><pre class="fragment">make -C src/c-lib -j `nproc` libstatic
</pre><p> <b>On Windows:</b></p>
<p>Build using Visual Studio or from a Developer Command Prompt: </p><pre class="fragment">msbuild src\gs1encoders.sln /t:gs1encoders /p:Configuration=Release /p:Platform=x64
</pre><p> This generates the library in <code>src\c-lib\build\library\x64\Release\gs1encoders.dll</code>.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Running the example application</h3>
<p>After building, you can test the library by running the interactive console application:</p>
<p><b>On Unix/macOS:</b> </p><pre class="fragment">make -C src/c-lib -j `nproc` app
LD_LIBRARY_PATH=src/c-lib/build src/c-lib/build/gs1encoders.bin
</pre><p> <b>On Windows:</b> </p><pre class="fragment">msbuild src\gs1encoders.sln /t:gs1encoders-app /p:Configuration=Release /p:Platform=x64
src\c-lib\build\bin\x64\Release\gs1encoders-app.exe
</pre><p> The example application provides an interactive menu for testing different input formats and features.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Using in your own C/C++ project</h3>
<p>To use the library in your C/C++ project you must:</p>
<ol type="1">
<li>Include <code><a class="el" href="gs1encoders_8h.html">gs1encoders.h</a></code> in your source files</li>
<li>Link against the library (<code>libgs1encoders.so</code>, <code>libgs1encoders.a</code>, <code>gs1encoders.dll</code>, or <code>gs1encoders.lib</code>)</li>
</ol>
<p>For a minimal example, create a <code>myapp.c</code> file as follows:</p>
<div class="fragment"><div class="line">#include &lt;stdio.h&gt;</div>
<div class="line">#include &quot;gs1encoders.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(void) {</div>
<div class="line">    gs1_encoder *gs = gs1_encoder_init(NULL);</div>
<div class="line">    if (!gs) return 1;</div>
<div class="line"> </div>
<div class="line">    printf(&quot;GS1 Syntax Engine version: %s\n&quot;, gs1_encoder_getVersion());</div>
<div class="line"> </div>
<div class="line">    gs1_encoder_free(gs);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>On Unix/macOS:</b></p>
<p>Compile and link: </p><pre class="fragment">gcc myapp.c -I&lt;path-to-gs1-syntax-engine&gt;/src/c-lib -L&lt;path-to-gs1-syntax-engine&gt;/src/c-lib/build -lgs1encoders -o myapp
</pre><p> Run: </p><pre class="fragment">LD_LIBRARY_PATH=&lt;path-to-gs1-syntax-engine&gt;/src/c-lib/build ./myapp
</pre><p> <b>On Windows:</b></p>
<p>Compile and link: </p><pre class="fragment">cl myapp.c /I&lt;path-to-gs1-syntax-engine&gt;\src\c-lib &lt;path-to-gs1-syntax-engine&gt;\src\c-lib\build\library\x64\Release\gs1encoders.lib
</pre><p> Run (ensure <code>gs1encoders.dll</code> is in the same directory or on PATH): </p><pre class="fragment">myapp.exe
</pre><h2><a class="anchor" id="example-uses"></a>
Example Uses</h2>
<p>The following are examples of how to use the library.</p>
<dl class="section note"><dt>Note</dt><dd>Using the library always begins by initialising the library with <a class="el" href="gs1encoders_8h.html#a111897e9846a97c2d3e446d2815b4410">gs1_encoder_init()</a> or <a class="el" href="gs1encoders_8h.html#af3a0f85afa4d367a1bca6875864e3a6d">gs1_encoder_init_ex()</a> and finishes by releasing the library with <a class="el" href="gs1encoders_8h.html#a0078a51318ba3551052c309fe48110ae">gs1_encoder_free()</a>.</dd>
<dd>
Unless otherwise specified, the getter functions return pointers to per-instance storage managed by this library and therefore must not be freed by the user. If their content must persist following a subsequent call to the same instance of the library then they must be copied to a user-managed buffer.</dd>
<dd>
Most of the setter and action functions of this library return a boolean indicating whether the function was successful and write an error message that can be accessed with <a class="el" href="gs1encoders_8h.html#af5407346cafcc509fe8bbd2dc170ae62">gs1_encoder_getErrMsg()</a> in the event of failure. Production code should check the output of the functions and where relevant do something appropriate which might include rendering the error message to the user. Error message string are provided in the English language in a single file that can be replaced at compile time.</dd></dl>
<p>Refer to the example console application (<code>gs1encoders-app.c</code>) for a comprehensive example of how to use this library.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
GS1 AI data validation and extraction (including GS1 Digital Link)</h3>
<p>The following code processes AI data input, validates it (reporting any failures) and displays the extracted AIs if the validation succeeds.</p>
<div class="fragment"><div class="line">gs1_encoder *ctx = gs1_encoder_init(NULL);              // Create a new instance of the library</div>
<div class="line"> </div>
<div class="line">// gs1_encoder_permitUnknownAIs(ctx, true);             // Uncomment only if it is necessary to handle AIs</div>
<div class="line">                                                        // that are not known to the library</div>
<div class="line"> </div>
<div class="line">// Input provided as a bracketed AI element string</div>
<div class="line">//</div>
<div class="line">bool ret = gs1_encoder_setAIdataStr(ctx, &quot;(01)12312312312333(10)ABC123(99)TEST&quot;);</div>
<div class="line"> </div>
<div class="line">// Alternatively, the input may be given in the following formats:</div>
<div class="line">//</div>
<div class="line">// bool ret = gs1_encoder_setDataStr(ctx,               // Unbracketed element string, &quot;^&quot; = FNC1</div>
<div class="line">//                &quot;^011231231231233310ABC123^99TEST&quot;);</div>
<div class="line">//</div>
<div class="line">// bool ret = gs1_encoder_setDataStr(ctx,               // GS1 Digital Link URI</div>
<div class="line">//                &quot;https://example.com/01/12312312312333/10/ABC123/99/TEST&quot;);</div>
<div class="line">//</div>
<div class="line">// bool ret = gs1_encoder_setScanData(ctx,              // Barcode scan data, containing a &quot;GS&quot; (ASCII 0x1D) separator</div>
<div class="line">//                &quot;]Q1011231231231233310ABC123&quot; &quot;\x1D&quot; &quot;99TEST&quot;);</div>
<div class="line"> </div>
<div class="line">if (!ret) {</div>
<div class="line">    printf(&quot;ERROR: %s\n&quot;, gs1_encoder_getErrMsg(ctx));  // Display a descriptive error message</div>
<div class="line">    char *errMarkup = gs1_encoder_getErrMarkup(ctx);</div>
<div class="line">    if (*errMarkup != &#39;\0&#39;)                             // Display the invalid AI in the case of a Linting failure</div>
<div class="line">        printf(&quot;Bad AI data: %s\n&quot;, errMarkup);</div>
<div class="line">    abort();                                            // Finally, handle the error in an application-specific way</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">char **hri;</div>
<div class="line">int numHRI = gs1_encoder_getHRI(ctx, &amp;hri);             // Display the extracted AI data as HRI text</div>
<div class="line">for (int i = 0; i &lt; numHRI; i++) {</div>
<div class="line">    printf(&quot;%s\n&quot;, hri[i]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">gs1_encoder_free(ctx);                                  // Release the instance of the library</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Converting an AI element string to barcode message data</h3>
<p>In this example we process a bracketed AI element string to convert it into barcode message data, suitable for carrying in a GS1 barcode symbol.</p>
<div class="fragment"><div class="line">gs1_encoder *ctx = gs1_encoder_init(NULL);</div>
<div class="line"> </div>
<div class="line">bool ret = gs1_encoder_setAIdataStr(ctx,        // Accept a bracketed AI element string</div>
<div class="line">    &quot;(01)12312312312333(10)ABC123(99)TEST&quot;);</div>
<div class="line"> </div>
<div class="line">if (!ret) {</div>
<div class="line">    // Handle error and return</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">printf(&quot;%s\n&quot;, gs1_encoder_getDataStr(ctx));    // Render the barcode message buffer</div>
<div class="line"> </div>
<div class="line">gs1_encoder_free(ctx);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The barcode message data read and emitted by this library uses a harmonised format that does not concern itself with internal encoding quirks of various symbologies. In the harmonised barcode message data: </dd>
<dd>
<ul>
<li>A leading <code>^</code> always indicates GS1 Application Identifier syntax data, i.e. a notional FNC1 in first character position. (This is even true for DotCode in whose <em>internal encoding</em> the literal FNC1 non-data character may have an inverted meaning for certain messages depending upon their regular data content.)</li>
<li>A <code>^</code> at any other position represents a notional FNC1 non-data Application Identifier separator character. (This is even the case for QR Code in whose <em>internal encoding</em> a <code>%</code> character or <code>{GS}</code> character takes on the AI separator role typically assigned to the FNC1 non-data character, depending upon the effectuve encodation mode.) </li>
</ul>
</dd>
<dd>
Additionally, barcode image encoder libraries have differing conventions for how to input FNC1 characters, extending to whether it is necessary to be explicit about the notional FNC1 character in the first position when specifying a GS1 Application Identifier syntax symbol. </dd>
<dd>
Consequently, the barcode message data emitted by this library may need to be post-processed to align to the specific requirements of whatever symbol generation library is in use.</dd></dl>
<h3><a class="anchor" id="autotoc_md6"></a>
Barcode scan data processing</h3>
<p>In this example we process scan data from a barcode reader to extract the AI data.</p>
<div class="fragment"><div class="line">gs1_encoder *ctx = gs1_encoder_init(NULL);</div>
<div class="line"> </div>
<div class="line">// Disable validation of mandatory association between AIs if the symbol may</div>
<div class="line">// be one of multiple on a label</div>
<div class="line">setValidationEnabled(ctx, gs1_encoder_vREQUISITE_AIS, false);</div>
<div class="line"> </div>
<div class="line">bool ret = gs1_encoder_setScanData(ctx,</div>
<div class="line">               &quot;]Q1011231231231233310ABC123&quot; &quot;\x1D&quot; &quot;99TEST&quot;);</div>
<div class="line"> </div>
<div class="line">if (!ret) {</div>
<div class="line">    // Handle error and return</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">char **hri;</div>
<div class="line">int numHRI = gs1_encoder_getHRI(ctx, &amp;hri);</div>
<div class="line">for (int i = 0; i &lt; numHRI; i++) {</div>
<div class="line">    printf(&quot;%s\n&quot;, hri[i]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// If it is necessary to know the &quot;symbology&quot; that was scanned then this can</div>
<div class="line">// be read using gs1_encoder_getSym(), however note the caveats given in the</div>
<div class="line">// description of gs1_encoder_setScanData()</div>
<div class="line"> </div>
<div class="line">gs1_encoder_free(ctx);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is required that AIM Symbology Identifiers are enabled on the barcode reader.</dd>
<dd>
It is assumed the scanned barcode message "survives the channel" intact, i.e. that no character substitutions have been made by the reader, in particular that any embedded FNC1 separator characters are correctly represented by GS characters (ASCII 29). If this is not the case then the scanned data should be pre-processed to meet this requirement.</dd></dl>
<h2><a class="anchor" id="autotoc_md7"></a>
Compile-Time Configuration Macros</h2>
<p>The following macros may be defined at compile time to enable or disable optional features:</p>
<p><code>GS1_ENCODERS_ERR_LANG=&lt;LANG&gt;</code> : Used to specify alternative translation strings for error messages. Create a new header file named <code>tr_&lt;LANG&gt;.h</code> based on the existing <code>tr_EN.h</code> file.</p>
<p><code>EXCLUDE_EMBEDDED_AI_TABLE</code> : Excludes the embedding a table of AI properties in order to reduce the size of the library. The table of AI definitions must be populated by parsing from the GS1 Syntax Dictionary instead, without falling back to the embedded instance.</p>
<p><code>EXCLUDE_SYNTAX_DICTIONARY_LOADER</code> : Excludes functions for populating the table of AIs by parsing the GS1 Syntax Dictionary. The AI definitions must be embedded for the library to function, i.e. this option is mutually exclusive of <code>EXCLUDE_EMBEDDED_AI_TABLE</code>.</p>
<p><code>GS1_ENCODERS_CUSTOM_HEAP_MANAGEMENT_H=&lt;CUSTOM_HEADER.h&gt;</code> : Points to a file that declares alternative heap management routines via the <code>GS1_ENCODERS_CUSTOM_MALLOC</code>, <code>GS1_ENCODERS_CUSTOM_CALLOC</code>, <code>GS1_ENCODERS_CUSTOM_REALLOC</code> and <code>GS1_ENCODERS_CUSTOM_FREE</code> macros. See below for implementation details.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Custom heap management routines example</h3>
<p>Define <code>GS1_ENCODERS_CUSTOM_HEAP_MANAGEMENT_H=my_alloc.h</code>.</p>
<p>Example declarations in <code>my_alloc.h</code>:</p>
<div class="fragment"><div class="line">#define GS1_ENCODERS_CUSTOM_MALLOC(sz) my_malloc(sz)</div>
<div class="line">#define GS1_ENCODERS_CUSTOM_CALLOC(nm, sz) my_calloc(nm, sz)</div>
<div class="line">#define GS1_ENCODERS_CUSTOM_REALLOC(p, sz) my_realloc(p, sz)</div>
<div class="line">#define GS1_ENCODERS_CUSTOM_FREE(p) my_free(p)</div>
<div class="line"> </div>
<div class="line">void* my_malloc(size_t s);</div>
<div class="line">void* my_calloc(size_t nm, size_t sz);</div>
<div class="line">void* my_realloc(void *p, size_t sz);</div>
<div class="line">void my_free(void *p);</div>
</div><!-- fragment --><p>Example implementation:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line">void* my_malloc(size_t s) {</div>
<div class="line">        void* p = malloc(s);</div>
<div class="line">        printf(&quot;*** MALLOC %zu =&gt; %p\n&quot;, s, p);</div>
<div class="line">        return p;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void* my_calloc(size_t nm, size_t sz) {</div>
<div class="line">        void* p = calloc(nm, sz);</div>
<div class="line">        printf(&quot;*** CALLOC %zu %zu =&gt; %p\n&quot;, nm, sz, p);</div>
<div class="line">        return p;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void* my_realloc(void *p, size_t sz) {</div>
<div class="line">        void* q = realloc(p, sz);</div>
<div class="line">        printf(&quot;*** REALLOC %p %zu =&gt; %p\n&quot;, p, sz, q);</div>
<div class="line">        return q;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void my_free(void *p) {</div>
<div class="line">        printf(&quot;*** FREE %p\n&quot;, p);</div>
<div class="line">        free(p);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
